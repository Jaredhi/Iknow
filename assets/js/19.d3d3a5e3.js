(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{440:function(r,v,t){"use strict";t.r(v);var s=t(15),o=Object(s.a)({},(function(){var r=this,v=r.$createElement,t=r._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[r._v("#")]),r._v(" 前言")]),r._v(" "),t("p",[t("strong",[r._v("(1) 基本概念：")]),r._v("\nJVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。\n"),t("img",{attrs:{src:"https://jinterest.oss-cn-shenzhen.aliyuncs.com/img/JVM/JVM_1.jpg",alt:""}})]),r._v(" "),t("p",[t("strong",[r._v("(2) 运行过程：")]),r._v("\n我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，\n而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码 。\n也就是如下：\n① Java 源文件—->编译器—->字节码文件\n② 字节码文件—->JVM—->机器码\n每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。\n"),t("img",{attrs:{src:"https://jinterest.oss-cn-shenzhen.aliyuncs.com/img/JVM/JVM_2.jpg",alt:""}})]),r._v(" "),t("h2",{attrs:{id:"_1、线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、线程"}},[r._v("#")]),r._v(" 1、线程")]),r._v(" "),t("p",[r._v("这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。 "),t("strong",[r._v("当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。")])]),r._v(" "),t("p",[r._v("Hotspot JVM 后台运行的系统线程主要有下面几个：\n"),t("img",{attrs:{src:"https://jinterest.oss-cn-shenzhen.aliyuncs.com/img/JVM/JVM_%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B.jpg",alt:""}})]),r._v(" "),t("h2",{attrs:{id:"_2、jvm内存区域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、jvm内存区域"}},[r._v("#")]),r._v(" 2、JVM内存区域")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://jinterest.oss-cn-shenzhen.aliyuncs.com/img/JVM/JVM_%E5%86%85%E5%AD%98.jpg",alt:""}})]),r._v(" "),t("p",[t("strong",[r._v("线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内,")]),r._v(" 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。"),t("strong",[r._v("线程共享区域随虚拟机的启动/关闭而创建/销毁")])]),r._v(" "),t("h2",{attrs:{id:"_3、jvm-运行时内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、jvm-运行时内存"}},[r._v("#")]),r._v(" 3、JVM 运行时内存")]),r._v(" "),t("p",[r._v("Java 堆从 GC 的角度还可以细分为: "),t("strong",[r._v("新生代")]),r._v(" (Eden 区、From Survivor 区和 To Survivor 区)和 "),t("strong",[r._v("老年代")]),r._v("。")]),r._v(" "),t("p",[t("strong",[r._v("一、新生代")]),r._v("\n是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。")]),r._v(" "),t("ol",[t("li",[t("strong",[r._v("Eden 区")]),r._v("\nJava 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。")]),r._v(" "),t("li",[t("strong",[r._v("ServivorFrom")]),r._v("\n上一次 GC 的幸存者，作为这一次 GC 的被扫描者。")]),r._v(" "),t("li",[t("strong",[r._v("ServivorTo")]),r._v("\n保留了一次 MinorGC 过程中的幸存者。")]),r._v(" "),t("li",[t("strong",[r._v("MinorGC 的过程（复制->清空->互换）")]),r._v("\nMinorGC 采用复制算法。\n"),t("ol",[t("li",[t("strong",[r._v("eden、servicorFrom 复制到 ServicorTo，年龄+1")]),r._v("\n首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）；")]),r._v(" "),t("li",[t("strong",[r._v("清空 eden、servicorFrom")]),r._v("\n然后，清空 Eden 和 ServicorFrom 中的对象；")]),r._v(" "),t("li",[t("strong",[r._v("ServicorTo 和 ServicorFrom 互换")]),r._v("\n最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。")])])])]),r._v(" "),t("p",[t("strong",[r._v("二、老年代")]),r._v("\n主要存放应用程序中生命周期长的内存对象。")]),r._v(" "),t("p",[r._v("老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。")]),r._v(" "),t("p",[r._v("MajorGC 采用 "),t("strong",[r._v("标记清除算法")]),r._v(" ：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。")]),r._v(" "),t("p",[t("strong",[r._v("三、永久代")]),r._v("\n指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同, "),t("strong",[r._v("GC 不会在主程序运行期对永久区域进行清理。")]),r._v(" 所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。")]),r._v(" "),t("ul",[t("li",[r._v("JAVA8 与元数据\n"),t("strong",[r._v("在 Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代")]),r._v("。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于："),t("strong",[r._v("元空间并不在虚拟机中，而是使用本地内存。")]),r._v(" 因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。")])]),r._v(" "),t("h2",{attrs:{id:"_4、垃圾回收与算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、垃圾回收与算法"}},[r._v("#")]),r._v(" 4、垃圾回收与算法")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://jinterest.oss-cn-shenzhen.aliyuncs.com/img/JVM/JVM_GC.jpg",alt:""}})])])}),[],!1,null,null,null);v.default=o.exports}}]);