(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{448:function(_,v,t){"use strict";t.r(v);var n=t(15),s=Object(n.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"_1、java-中用到的线程调度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、java-中用到的线程调度"}},[_._v("#")]),_._v(" 1、Java 中用到的线程调度")]),_._v(" "),t("p",[t("strong",[_._v("抢占式调度：")]),_._v("\n抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。")]),_._v(" "),t("p",[t("strong",[_._v("协同式调度：")]),_._v("\n协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。")]),_._v(" "),t("p",[t("strong",[_._v("JVM 的线程调度实现（抢占式调度）")]),_._v("\njava 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，"),t("strong",[_._v("且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片")]),_._v(" ，反之，优先级低的分到的执行时间少但不会分配不到执行时间。")]),_._v(" "),t("p",[t("strong",[_._v("线程让出 cpu 的情况：")])]),_._v(" "),t("ol",[t("li",[_._v("当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。")]),_._v(" "),t("li",[_._v("当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I/O 上。")]),_._v(" "),t("li",[_._v("当前运行线程结束，即运行完 run()方法里面的任务。")])]),_._v(" "),t("h2",{attrs:{id:"_2、进程调度算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、进程调度算法"}},[_._v("#")]),_._v(" 2、进程调度算法")]),_._v(" "),t("p",[t("strong",[_._v("一、优先调度算法")])]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("先来先服务调度算法（FCFS）")]),_._v("\n当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("短作业(进程)优先调度算法")]),_._v("\n短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。")])])]),_._v(" "),t("p",[t("strong",[_._v("二、高优先权优先调度算法")]),_._v("\n为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。")]),_._v(" "),t("ol",[t("li",[t("strong",[_._v("非抢占式优先权算法")]),_._v("\n在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。")]),_._v(" "),t("li",[t("strong",[_._v("抢占式优先权调度算法")]),_._v("\n在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。"),t("strong",[_._v("但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行")]),_._v(" ，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。")]),_._v(" "),t("li",[t("strong",[_._v("高响应比优先调度算法")]),_._v("\n在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率 a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：\n"),t("img",{attrs:{src:"https://jinterest.oss-cn-shenzhen.aliyuncs.com/img/Thread/%E4%BC%98%E5%85%88%E6%9D%83Rp.jpg",alt:""}}),_._v("\n(1) 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。\n(2) 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。\n(3) 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。")])]),_._v(" "),t("p",[t("strong",[_._v("三、基于时间片的轮转调度算法")])]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("时间片轮转法")]),_._v("\n在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。"),t("strong",[_._v("当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程")]),_._v(" ，同时也让它执行一个时间片。"),t("strong",[_._v("这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("多级反馈队列调度算法")]),_._v("\n(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。\n(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。\n(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。")])])]),_._v(" "),t("p",[_._v("在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。")]),_._v(" "),t("h2",{attrs:{id:"_3、什么是-cas-比较并交换-乐观锁机制-锁自旋"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、什么是-cas-比较并交换-乐观锁机制-锁自旋"}},[_._v("#")]),_._v(" 3、什么是 CAS（比较并交换-乐观锁机制-锁自旋）")]),_._v(" "),t("p",[t("strong",[_._v("概念及特性")]),_._v("\nCAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。"),t("strong",[_._v("V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。")]),_._v(" CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。"),t("strong",[_._v("当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。")]),_._v(" 基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。")]),_._v(" "),t("p",[t("strong",[_._v("..........")]),_._v(" "),t("strong",[_._v("..........")]),_._v(" "),t("strong",[_._v("..........")])]),_._v(" "),t("p",[t("strong",[_._v("ABA 问题")]),_._v("\nCAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。\n比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。")]),_._v(" "),t("p",[_._v("部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。")]),_._v(" "),t("h2",{attrs:{id:"_4、什么是-aqs-抽象的队列同步器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、什么是-aqs-抽象的队列同步器"}},[_._v("#")]),_._v(" 4、什么是 AQS（抽象的队列同步器）")]),_._v(" "),t("p",[_._v("AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，"),t("strong",[_._v("AQS 定义了一套多线程访问共享资源的同步器框架")]),_._v(" ，许多同步类实现都依赖于它，如常用的\nReentrantLock/Semaphore/CountDownLatch")]),_._v(" "),t("p",[t("strong",[_._v("..........")]),_._v(" "),t("strong",[_._v("..........")]),_._v(" "),t("strong",[_._v("..........")])]),_._v(" "),t("p",[t("em",[_._v("[内容仅作个人笔记，来源于网络 侵权请联系]")])])])}),[],!1,null,null,null);v.default=s.exports}}]);